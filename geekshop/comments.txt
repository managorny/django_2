* Урок 1.
Mac OS.
Сделал venv через Pycharm, скрины в папке screenshots. Виртуалки через терминал до этого также создавал на Linux.
Сделал алиас на запуск сервера в .bash_profile.
Сделал контекстный процессор в корзине.
Для отправки почты в методах модели хотел использовать datetime.datetime.now(). Но получил ошибку, очевидно из-за таймзоны. Пофиксил.
Добавил свой генератор соли.
Понял, что не очень удобно когда сообщение не отправлено, при этом юзер создался. Пока не разбирался как сделать по другому.
Настроил изначально через smtp.gmail.com, но пока ошибки (Google блокирует вход под учеткой).
С smtp.mail.ru получилось. Скриншот в папке screenshots.
Также столкнулся с проблемой неуникальности email, ссылка верификации становится не рабочей, т.к. возвращается не один юзер.
Хотел сделать уведомление об отправке в виде js-ного alert а главной странице, но решил, что не стоит наделять главную стр. тем, чем не нужно,
в итоге сделал через шаблон.

------------------------------------------------------------------------------------------------------------------------

* Урок 2.
Добавил очистку activation_key после первой удачной верификации (user.activation_key = '' в authapp.views)
Сделал авторизацию через Google.
Сделал авторизацию через ВКонтакте. Однако заметил, что после авторизации логин в базе с каким-то доп. набором символов.
Добавил профиль.
Добавил редактирование пользователя с 2мя формами (обычная и профиль).
Добавил сигнал на сохранение профиля при создании либо изменении юзера.
Сделал расширенную регистрацию из соцсетей через pipeline. При регистрации через Google пока добавил в aboutMe ссылку на картинку пользователя Google.
Добавил также расширенное для ВК, не увидел там информации: возвраст, обо мне, пол. Возможно зависит от аккаунта, на всякий случай оставил.
Добавил сбор screen_name и хотел email, но понял потом, что он и так собирается.
Ошибку AuthForbidden вызвал. Скриншот в папке screenshots.
Столкнулся с проблемой одинаковых username если из 2х соцсетей регестрироваться (в случае с pipeline username из ВК без доп. символов создается).
------------------------------------------------------------------------------------------------------------------------

* Урок 3.

Добавил всплывающее меню без бутстрапа, т.к. почему-то он все равно переопределяет мои стили и делает оступы у всей страницы по другому.
Добавил полный CRUD для ordersapp.
Добавил изменение статуса после совершения покупки.
------------------------------------------------------------------------------------------------------------------------

* Урок 4.
Добавил изменение остатков товаров, выбрал через сигналы.
Было следующее приключение:
---
Нашел проблему когда товара на складе 1 штука, тогда выпадает ошибка:
 "IntegrityError at /orders/order/create/ CHECK constraint failed: mainapp_product", - очевидно ошибка при работе с базой.
Подумал, что т.к. у нас перед сохранением нового заказа на складе уже числится 0 товара, и мы пытаемся из него вычесть кол-во, при этом из корзины еще не удалили.
Т.е. при сохранении заказа, сначала должно срабатывать удаление из корзины, затем уже сохранение товара...
Однако если будет ошибка при сохранении заказа, корзина уже будет удалена.
Предполагаю, что лучше не делать увеличение остатка при удалении корзины если на складе уже 0,
и уменьшение остатка при сохранении заказа, если также на складе уже 0 (т.к. при создании корзины уже удалили со склада).
Далее понял, что дело не только в 0, но и во всех случаях, когда кол-во товара в заказе больше остатка. Поэтому добавил условие не с 0, а со сравнением этих чисел.
И делаю так, что не пытаюсь еще раз вычесть кол-во товара заказа из остатка, т.к. это уже сделано при создании корзины,
в случае, когда остаток меньше либо равен кол-ву товара в заказе.
---
Кажется, что вообще не нужно делать повторного вычетания при сохранении заказа, если это уже сделано при создании корзины.
Но пока не уверен, что все продумал. Т.к. корзина может жить долго, надо будет подумать дальше над вариантами поведения.

Добавил JQuery и django-dynamic-formset. Добавил начало переделки файла с JQuery на чистый JS.
Начал "делать" обновление цены в зависимости от выбранного товара и его кол-ва.
Пока сделал только переопределение переменных с товарами, кол-вом и ценами.
Пока начал с плана.
План:
1) сохранять все изначально загруженные товары и их атрибуты (кол-во и цена).
    Предполагается, что будет 3 массива, товары(str(name) или int в случае, если решу делать через id), кол-во(int), цены(float):
        [товар1, товар2, ...], [кол-во товара1, кол-во товара2, ...], [цена товара1, цена товара 2, ...]
2) переопределять переменные с уже загруженными товарами и их атрибутами, если товар либо его атрибуты поменялись.
3) добавлять в переменные новые товары.
4) делать запрос на получение цены для нового товара.
5) обновлять общую стоимость и общее кол-во товаров заказа.
6) добавить проверку общего кол-ва товара на складе и не давать брать сколько угодно товара, а столько сколько сейчас в базе.

В момент когда переделал _price на получение текста через document.querySelector , почему-то пропали кнопки "добавить продукт" и "удалить".
Вероятно из-за ошибки "Uncaught TypeError: Cannot read property 'outerText' of null", т.к. текст еще не загрузился, и поэтому null.
Добавил условие, забирать текст, когда этот span уже загрузился.
